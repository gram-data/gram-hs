<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-- | Core Pattern data type and basic operations.</span><span>
</span><span id="line-2"></span><span class="hs-comment">--</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- This module defines the fundamental Pattern type as a recursive structure</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- that can represent graph elements and sequences.</span><span>
</span><span id="line-5"></span><span class="hs-comment">--</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- == Conceptual Model: Patterns as Sequences</span><span>
</span><span id="line-7"></span><span class="hs-comment">--</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Conceptually, a Pattern is a sequence of elements with associated metadata.</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- For example, the pattern &quot;3 1 4 1 9 5&quot; is a sequence of 6 elements. The Pattern</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- type represents such sequences where:</span><span>
</span><span id="line-11"></span><span class="hs-comment">--</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- * @value@ - Metadata or information about the sequence (e.g., sequence name, type, or properties)</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- * @elements@ - The sequence itself, which is a list of Pattern instances</span><span>
</span><span id="line-14"></span><span class="hs-comment">--</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- While implemented using a recursive tree structure, the primary semantic is</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- sequence-based. Each element in the sequence is itself a Pattern, enabling</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- arbitrarily nested and complex sequence structures.</span><span>
</span><span id="line-18"></span><span class="hs-comment">--</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- == Implementation: Recursive Structure</span><span>
</span><span id="line-20"></span><span class="hs-comment">--</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- The Pattern type is implemented as a recursive tree structure where:</span><span>
</span><span id="line-22"></span><span class="hs-comment">--</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- * Each pattern stores a @value@ of type @v@ (the metadata)</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- * Each pattern contains an @elements@ list of zero or more Pattern instances (the sequence)</span><span>
</span><span id="line-25"></span><span class="hs-comment">-- * The recursive structure enables patterns to contain patterns containing patterns, etc.</span><span>
</span><span id="line-26"></span><span class="hs-comment">--</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- This recursive implementation enables:</span><span>
</span><span id="line-28"></span><span class="hs-comment">--</span><span>
</span><span id="line-29"></span><span class="hs-comment">-- * Leaf patterns: Sequences with no elements (@elements == []@), representing simple entities</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- * Patterns with elements: Sequences containing one or more pattern elements, representing</span><span>
</span><span id="line-31"></span><span class="hs-comment">--   relationships, subgraphs, or complex structures</span><span>
</span><span id="line-32"></span><span class="hs-comment">-- * Arbitrary nesting: Patterns can contain patterns containing patterns, enabling</span><span>
</span><span id="line-33"></span><span class="hs-comment">--   hierarchical and deeply nested sequence structures</span><span>
</span><span id="line-34"></span><span class="hs-comment">--</span><span>
</span><span id="line-35"></span><span class="hs-comment">-- == Values and Pattern Association</span><span>
</span><span id="line-36"></span><span class="hs-comment">--</span><span>
</span><span id="line-37"></span><span class="hs-comment">-- Each Pattern instance associates a value with a sequence of elements:</span><span>
</span><span id="line-38"></span><span class="hs-comment">--</span><span>
</span><span id="line-39"></span><span class="hs-comment">-- * The @value@ field stores metadata about the pattern. This can be any type @v@,</span><span>
</span><span id="line-40"></span><span class="hs-comment">--   such as a string identifier, an integer, a custom data type, etc.</span><span>
</span><span id="line-41"></span><span class="hs-comment">-- * The @value@ is associated with the pattern instance itself, not with individual</span><span>
</span><span id="line-42"></span><span class="hs-comment">--   elements in the sequence.</span><span>
</span><span id="line-43"></span><span class="hs-comment">-- * All patterns in a structure must share the same value type @v@ (enforced by the type system).</span><span>
</span><span id="line-44"></span><span class="hs-comment">--</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- For example, a pattern representing a graph node might have @value = &quot;Person&quot;@</span><span>
</span><span id="line-46"></span><span class="hs-comment">-- (metadata indicating the node type) and @elements = []@ (empty sequence, indicating a leaf).</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- A pattern representing a relationship might have @value = &quot;knows&quot;@ (the relationship type)</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- and @elements = [nodeA, nodeB]@ (a sequence of two node patterns).</span><span>
</span><span id="line-49"></span><span class="hs-comment">--</span><span>
</span><span id="line-50"></span><span class="hs-comment">-- == Elements and Sequence Structure</span><span>
</span><span id="line-51"></span><span class="hs-comment">--</span><span>
</span><span id="line-52"></span><span class="hs-comment">-- The @elements@ field forms the sequence structure of the pattern:</span><span>
</span><span id="line-53"></span><span class="hs-comment">--</span><span>
</span><span id="line-54"></span><span class="hs-comment">-- * An empty sequence (@elements == []@) represents a leaf pattern - a pattern with no elements</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- * A non-empty sequence represents a pattern containing one or more pattern elements</span><span>
</span><span id="line-56"></span><span class="hs-comment">-- * The elements are ordered and maintain their sequence order</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- * Each element in the sequence is itself a Pattern, enabling recursive nesting</span><span>
</span><span id="line-58"></span><span class="hs-comment">--</span><span>
</span><span id="line-59"></span><span class="hs-comment">-- The sequence structure enables hierarchical patterns:</span><span>
</span><span id="line-60"></span><span class="hs-comment">--</span><span>
</span><span id="line-61"></span><span class="hs-comment">-- * A pattern can contain other patterns as its elements</span><span>
</span><span id="line-62"></span><span class="hs-comment">-- * Those element patterns can themselves contain patterns</span><span>
</span><span id="line-63"></span><span class="hs-comment">-- * This enables arbitrary depth nesting while maintaining the sequence semantic</span><span>
</span><span id="line-64"></span><span class="hs-comment">--</span><span>
</span><span id="line-65"></span><span class="hs-comment">-- For example, a graph pattern might have @elements = [node1, node2, relationship1]@</span><span>
</span><span id="line-66"></span><span class="hs-comment">-- where each element is a Pattern. The relationship pattern itself might have</span><span>
</span><span id="line-67"></span><span class="hs-comment">-- @elements = [nodeA, nodeB]@, creating a nested structure.</span><span>
</span><span id="line-68"></span><span class="hs-comment">--</span><span>
</span><span id="line-69"></span><span class="hs-comment">-- == Type Safety and Type Parameter @v@</span><span>
</span><span id="line-70"></span><span class="hs-comment">--</span><span>
</span><span id="line-71"></span><span class="hs-comment">-- The Pattern type is parameterized over value type @v@:</span><span>
</span><span id="line-72"></span><span class="hs-comment">--</span><span>
</span><span id="line-73"></span><span class="hs-comment">-- * @Pattern v@ allows patterns to store values of any type @v@</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- * All patterns in a structure must share the same value type @v@</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- * This type consistency is enforced by Haskell's type system</span><span>
</span><span id="line-76"></span><span class="hs-comment">-- * The type parameter ensures type safety when working with patterns</span><span>
</span><span id="line-77"></span><span class="hs-comment">--</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- For example:</span><span>
</span><span id="line-79"></span><span class="hs-comment">--</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- * @Pattern String@ - patterns storing string values</span><span>
</span><span id="line-81"></span><span class="hs-comment">-- * @Pattern Int@ - patterns storing integer values</span><span>
</span><span id="line-82"></span><span class="hs-comment">-- * @Pattern Person@ - patterns storing custom Person values</span><span>
</span><span id="line-83"></span><span class="hs-comment">--</span><span>
</span><span id="line-84"></span><span class="hs-comment">-- Type consistency means that if you have a @Pattern String@, all patterns in</span><span>
</span><span id="line-85"></span><span class="hs-comment">-- its @elements@ list must also be @Pattern String@. This prevents mixing</span><span>
</span><span id="line-86"></span><span class="hs-comment">-- different value types within a single pattern structure.</span><span>
</span><span id="line-87"></span><span class="hs-comment">--</span><span>
</span><span id="line-88"></span><span class="hs-comment">-- == Mathematical Foundation</span><span>
</span><span id="line-89"></span><span class="hs-comment">--</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- Patterns form the foundation for category-theoretic graph representations.</span><span>
</span><span id="line-91"></span><span class="hs-comment">-- The recursive structure enables functor instances (to be added in future phases)</span><span>
</span><span id="line-92"></span><span class="hs-comment">-- and supports various graph interpretations through categorical views. The sequence</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- semantic aligns with categorical composition and transformation operations.</span><span>
</span><span id="line-94"></span><span class="hs-comment">--</span><span>
</span><span id="line-95"></span><span class="hs-comment">-- == Examples</span><span>
</span><span id="line-96"></span><span class="hs-comment">--</span><span>
</span><span id="line-97"></span><span class="hs-comment">-- Leaf pattern (node):</span><span>
</span><span id="line-98"></span><span class="hs-comment">--</span><span>
</span><span id="line-99"></span><span class="hs-comment">-- &gt;&gt;&gt; leaf = Pattern { value = &quot;node1&quot;, elements = [] }</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- &gt;&gt;&gt; value leaf</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- &quot;node1&quot;</span><span>
</span><span id="line-102"></span><span class="hs-comment">-- &gt;&gt;&gt; elements leaf</span><span>
</span><span id="line-103"></span><span class="hs-comment">-- []</span><span>
</span><span id="line-104"></span><span class="hs-comment">--</span><span>
</span><span id="line-105"></span><span class="hs-comment">-- Pattern with children:</span><span>
</span><span id="line-106"></span><span class="hs-comment">--</span><span>
</span><span id="line-107"></span><span class="hs-comment">-- &gt;&gt;&gt; child1 = Pattern { value = &quot;child1&quot;, elements = [] }</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- &gt;&gt;&gt; child2 = Pattern { value = &quot;child2&quot;, elements = [] }</span><span>
</span><span id="line-109"></span><span class="hs-comment">-- &gt;&gt;&gt; parent = Pattern { value = &quot;parent&quot;, elements = [child1, child2] }</span><span>
</span><span id="line-110"></span><span class="hs-comment">-- &gt;&gt;&gt; value parent</span><span>
</span><span id="line-111"></span><span class="hs-comment">-- &quot;parent&quot;</span><span>
</span><span id="line-112"></span><span class="hs-comment">-- &gt;&gt;&gt; length (elements parent)</span><span>
</span><span id="line-113"></span><span class="hs-comment">-- 2</span><span>
</span><span id="line-114"></span><span class="hs-comment">-- &gt;&gt;&gt; map value (elements parent)</span><span>
</span><span id="line-115"></span><span class="hs-comment">-- [&quot;child1&quot;,&quot;child2&quot;]</span><span>
</span><span id="line-116"></span><span class="hs-comment">--</span><span>
</span><span id="line-117"></span><span class="hs-comment">-- Nested patterns (arbitrary depth):</span><span>
</span><span id="line-118"></span><span class="hs-comment">--</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- &gt;&gt;&gt; level3 = Pattern { value = &quot;level3&quot;, elements = [] }</span><span>
</span><span id="line-120"></span><span class="hs-comment">-- &gt;&gt;&gt; level2 = Pattern { value = &quot;level2&quot;, elements = [level3] }</span><span>
</span><span id="line-121"></span><span class="hs-comment">-- &gt;&gt;&gt; level1 = Pattern { value = &quot;level1&quot;, elements = [level2] }</span><span>
</span><span id="line-122"></span><span class="hs-comment">-- &gt;&gt;&gt; nested = Pattern { value = &quot;root&quot;, elements = [level1] }</span><span>
</span><span id="line-123"></span><span class="hs-comment">-- &gt;&gt;&gt; value nested</span><span>
</span><span id="line-124"></span><span class="hs-comment">-- &quot;root&quot;</span><span>
</span><span id="line-125"></span><span class="hs-comment">-- &gt;&gt;&gt; value (head (elements nested))</span><span>
</span><span id="line-126"></span><span class="hs-comment">-- &quot;level1&quot;</span><span>
</span><span id="line-127"></span><span class="hs-comment">--</span><span>
</span><span id="line-128"></span><span class="hs-comment">-- Leaf patterns with different value types:</span><span>
</span><span id="line-129"></span><span class="hs-comment">--</span><span>
</span><span id="line-130"></span><span class="hs-comment">-- &gt;&gt;&gt; leafString = Pattern { value = &quot;text&quot;, elements = [] }</span><span>
</span><span id="line-131"></span><span class="hs-comment">-- &gt;&gt;&gt; leafInt = Pattern { value = 42, elements = [] }</span><span>
</span><span id="line-132"></span><span class="hs-comment">-- &gt;&gt;&gt; value leafString</span><span>
</span><span id="line-133"></span><span class="hs-comment">-- &quot;text&quot;</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- &gt;&gt;&gt; value leafInt</span><span>
</span><span id="line-135"></span><span class="hs-comment">-- 42</span><span>
</span><span id="line-136"></span><span class="hs-comment">--</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- Patterns with varying numbers of children:</span><span>
</span><span id="line-138"></span><span class="hs-comment">--</span><span>
</span><span id="line-139"></span><span class="hs-comment">-- &gt;&gt;&gt; zeroChildren = Pattern { value = &quot;zero&quot;, elements = [] }</span><span>
</span><span id="line-140"></span><span class="hs-comment">-- &gt;&gt;&gt; oneChild = Pattern { value = &quot;one&quot;, elements = [Pattern { value = &quot;child&quot;, elements = [] }] }</span><span>
</span><span id="line-141"></span><span class="hs-comment">-- &gt;&gt;&gt; manyChildren = Pattern { value = &quot;many&quot;, elements = [Pattern { value = &quot;c1&quot;, elements = [] }, Pattern { value = &quot;c2&quot;, elements = [] }] }</span><span>
</span><span id="line-142"></span><span class="hs-comment">-- &gt;&gt;&gt; length (elements zeroChildren)</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- 0</span><span>
</span><span id="line-144"></span><span class="hs-comment">-- &gt;&gt;&gt; length (elements oneChild)</span><span>
</span><span id="line-145"></span><span class="hs-comment">-- 1</span><span>
</span><span id="line-146"></span><span class="hs-comment">-- &gt;&gt;&gt; length (elements manyChildren)</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- 2</span><span>
</span><span id="line-148"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Pattern.Core.html"><span class="hs-identifier">Pattern.Core</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-149"></span><span>
</span><span id="line-150"></span><span class="hs-comment">-- | A recursive structure representing a sequence of pattern elements with</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- associated metadata.</span><span>
</span><span id="line-152"></span><span class="hs-comment">--</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- Conceptually, a Pattern is a sequence of elements with a value (metadata)</span><span>
</span><span id="line-154"></span><span class="hs-comment">-- associated with the sequence. For example, the pattern &quot;3 1 4 1 9 5&quot; is a</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- sequence of 6 elements. The Pattern type represents such sequences where</span><span>
</span><span id="line-156"></span><span class="hs-comment">-- each element is itself a Pattern, enabling recursive nesting.</span><span>
</span><span id="line-157"></span><span class="hs-comment">--</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- Patterns form the foundation for representing graph elements and sequences.</span><span>
</span><span id="line-159"></span><span class="hs-comment">-- Each pattern associates a value (metadata) of any type with a sequence of</span><span>
</span><span id="line-160"></span><span class="hs-comment">-- pattern elements. The recursive structure enables hierarchical and nested</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- sequences while maintaining the sequence semantic.</span><span>
</span><span id="line-162"></span><span class="hs-comment">--</span><span>
</span><span id="line-163"></span><span class="hs-comment">-- The Pattern type is intentionally minimal - it provides just the structure</span><span>
</span><span id="line-164"></span><span class="hs-comment">-- needed for recursive sequence representation. Classification functions</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- (identifying nodes, relationships, subgraphs) will be added in future phases.</span><span>
</span><span id="line-166"></span><span class="hs-comment">--</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- === Type Parameter @v@</span><span>
</span><span id="line-168"></span><span class="hs-comment">--</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- The @v@ type parameter allows patterns to store values of any type as metadata.</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- All patterns in a structure must share the same value type @v@. This type</span><span>
</span><span id="line-171"></span><span class="hs-comment">-- consistency is enforced by Haskell's type system, ensuring type safety when</span><span>
</span><span id="line-172"></span><span class="hs-comment">-- working with patterns.</span><span>
</span><span id="line-173"></span><span class="hs-comment">--</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- For example, @Pattern String@ represents patterns storing string values,</span><span>
</span><span id="line-175"></span><span class="hs-comment">-- @Pattern Int@ represents patterns storing integer values, and @Pattern Person@</span><span>
</span><span id="line-176"></span><span class="hs-comment">-- represents patterns storing custom Person values. All elements in a pattern's</span><span>
</span><span id="line-177"></span><span class="hs-comment">-- sequence must have the same value type as the pattern itself.</span><span>
</span><span id="line-178"></span><span class="hs-comment">--</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- === Pattern Variants</span><span>
</span><span id="line-180"></span><span class="hs-comment">--</span><span>
</span><span id="line-181"></span><span class="hs-comment">-- * Leaf pattern: @elements == []@ - a sequence with no elements, representing</span><span>
</span><span id="line-182"></span><span class="hs-comment">--   a simple entity or atomic pattern</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- * Pattern with elements: @elements@ contains one or more pattern elements -</span><span>
</span><span id="line-184"></span><span class="hs-comment">--   represents relationships, subgraphs, or complex sequence structures</span><span>
</span><span id="line-185"></span><span class="hs-comment">--</span><span>
</span><span id="line-186"></span><span class="hs-comment">-- === Examples</span><span>
</span><span id="line-187"></span><span class="hs-comment">--</span><span>
</span><span id="line-188"></span><span class="hs-comment">-- Creating a leaf pattern (node):</span><span>
</span><span id="line-189"></span><span class="hs-comment">--</span><span>
</span><span id="line-190"></span><span class="hs-comment">-- &gt;&gt;&gt; nodeA = Pattern { value = &quot;A&quot;, elements = [] }</span><span>
</span><span id="line-191"></span><span class="hs-comment">--</span><span>
</span><span id="line-192"></span><span class="hs-comment">-- Creating a relationship pattern:</span><span>
</span><span id="line-193"></span><span class="hs-comment">--</span><span>
</span><span id="line-194"></span><span class="hs-comment">-- &gt;&gt;&gt; nodeB = Pattern { value = &quot;B&quot;, elements = [] }</span><span>
</span><span id="line-195"></span><span class="hs-comment">-- &gt;&gt;&gt; relationship = Pattern { value = &quot;knows&quot;, elements = [nodeA, nodeB] }</span><span>
</span><span id="line-196"></span><span class="hs-comment">--</span><span>
</span><span id="line-197"></span><span class="hs-comment">-- Creating a graph pattern:</span><span>
</span><span id="line-198"></span><span class="hs-comment">--</span><span>
</span><span id="line-199"></span><span class="hs-comment">-- &gt;&gt;&gt; graph = Pattern { value = &quot;myGraph&quot;, elements = [nodeA, nodeB, relationship] }</span><span>
</span><span id="line-200"></span><span class="hs-comment">--</span><span>
</span><span id="line-201"></span><span class="hs-keyword">data</span><span> </span><span id="Pattern"><span class="annot"><a href="Pattern.Core.html#Pattern"><span class="hs-identifier hs-var">Pattern</span></a></span></span><span> </span><span id="local-6989586621679043074"><span class="annot"><a href="#local-6989586621679043074"><span class="hs-identifier hs-type">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Pattern"><span class="annot"><a href="Pattern.Core.html#Pattern"><span class="hs-identifier hs-var">Pattern</span></a></span></span><span> </span><span>
</span><span id="line-202"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | The metadata or value associated with this pattern sequence.</span><span>
</span><span id="line-203"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-204"></span><span>    </span><span class="hs-comment">-- The @value@ field stores metadata about the pattern sequence. This can be</span><span>
</span><span id="line-205"></span><span>    </span><span class="hs-comment">-- any type @v@, such as a string identifier, an integer, or a custom data type.</span><span>
</span><span id="line-206"></span><span>    </span><span class="hs-comment">-- The value is associated with the pattern instance itself, not with individual</span><span>
</span><span id="line-207"></span><span>    </span><span class="hs-comment">-- elements in the sequence.</span><span>
</span><span id="line-208"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-209"></span><span>    </span><span class="hs-comment">-- Type parameter @v@ allows for different value types. All patterns in a</span><span>
</span><span id="line-210"></span><span>    </span><span class="hs-comment">-- structure must share the same value type (enforced by the type system).</span><span>
</span><span id="line-211"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-212"></span><span>    </span><span class="hs-comment">-- === Examples</span><span>
</span><span id="line-213"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-214"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; value (Pattern { value = &quot;test&quot;, elements = [] })</span><span>
</span><span id="line-215"></span><span>    </span><span class="hs-comment">-- &quot;test&quot;</span><span>
</span><span id="line-216"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-217"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; value (Pattern { value = 42, elements = [] })</span><span>
</span><span id="line-218"></span><span>    </span><span class="hs-comment">-- 42</span><span>
</span><span id="line-219"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-220"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; value (Pattern { value = &quot;graph&quot;, elements = [Pattern { value = &quot;node&quot;, elements = [] }] })</span><span>
</span><span id="line-221"></span><span>    </span><span class="hs-comment">-- &quot;graph&quot;</span><span>
</span><span id="line-222"></span><span>    </span><span id="value"><span class="annot"><span class="annottext">forall v. Pattern v -&gt; v
</span><a href="Pattern.Core.html#value"><span class="hs-identifier hs-var hs-var">value</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679043074"><span class="hs-identifier hs-type">v</span></a></span><span>
</span><span id="line-223"></span><span>    </span><span>
</span><span id="line-224"></span><span>    </span><span class="hs-comment">-- | The sequence of pattern elements.</span><span>
</span><span id="line-225"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-226"></span><span>    </span><span class="hs-comment">-- The @elements@ field contains the sequence of pattern elements. An empty</span><span>
</span><span id="line-227"></span><span>    </span><span class="hs-comment">-- list @[]@ represents a leaf pattern (a sequence with no elements). A</span><span>
</span><span id="line-228"></span><span>    </span><span class="hs-comment">-- non-empty list represents a pattern containing one or more pattern elements</span><span>
</span><span id="line-229"></span><span>    </span><span class="hs-comment">-- in sequence.</span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-231"></span><span>    </span><span class="hs-comment">-- The elements maintain their sequence order and are accessible in that order.</span><span>
</span><span id="line-232"></span><span>    </span><span class="hs-comment">-- Each element in the sequence is itself a Pattern, enabling recursive nesting</span><span>
</span><span id="line-233"></span><span>    </span><span class="hs-comment">-- where patterns can contain patterns containing patterns, etc., enabling</span><span>
</span><span id="line-234"></span><span>    </span><span class="hs-comment">-- arbitrary nesting depth while maintaining the sequence semantic.</span><span>
</span><span id="line-235"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-236"></span><span>    </span><span class="hs-comment">-- === Examples</span><span>
</span><span id="line-237"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-238"></span><span>    </span><span class="hs-comment">-- Leaf pattern (empty children):</span><span>
</span><span id="line-239"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-240"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; elements (Pattern { value = &quot;leaf&quot;, elements = [] })</span><span>
</span><span id="line-241"></span><span>    </span><span class="hs-comment">-- []</span><span>
</span><span id="line-242"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-243"></span><span>    </span><span class="hs-comment">-- Pattern with children:</span><span>
</span><span id="line-244"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-245"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; leaf = Pattern { value = &quot;child&quot;, elements = [] }</span><span>
</span><span id="line-246"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; elements (Pattern { value = &quot;parent&quot;, elements = [leaf] })</span><span>
</span><span id="line-247"></span><span>    </span><span class="hs-comment">-- [Pattern {value = &quot;child&quot;, elements = []}]</span><span>
</span><span id="line-248"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-249"></span><span>    </span><span class="hs-comment">-- Pattern with multiple children:</span><span>
</span><span id="line-250"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-251"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; child1 = Pattern { value = &quot;child1&quot;, elements = [] }</span><span>
</span><span id="line-252"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; child2 = Pattern { value = &quot;child2&quot;, elements = [] }</span><span>
</span><span id="line-253"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; elements (Pattern { value = &quot;parent&quot;, elements = [child1, child2] })</span><span>
</span><span id="line-254"></span><span>    </span><span class="hs-comment">-- [Pattern {value = &quot;child1&quot;, elements = []},Pattern {value = &quot;child2&quot;, elements = []}]</span><span>
</span><span id="line-255"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="elements"><span class="annot"><span class="annottext">forall v. Pattern v -&gt; [Pattern v]
</span><a href="Pattern.Core.html#elements"><span class="hs-identifier hs-var hs-var">elements</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Pattern.Core.html#Pattern"><span class="hs-identifier hs-type">Pattern</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679043074"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-256"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-257"></span></pre></body></html>